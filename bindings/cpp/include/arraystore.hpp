// Copyright (C) 2019 Inkblot Software Limited
// THIS CODE IS 100% AUTOGENERATED, DO NOT EDIT EXCEPT EXPERIMENTALLY

#pragma once

#include <arraystore.h>
#include <cassert>
#include <stdexcept>

namespace arraystore {

using Key = int64_t;


//  ----------------------------------------------------------------------
//  Publicly-visible classes

class ASEnv;
class ASTxn;
class I32Store;
class I64Store;
class F32Store;
class F64Store;
class ByteStore;


//  ----------------------------------------------------------------------
//  asenv_t wrapper

class ASEnv {
    asenv_t *_handle = nullptr;
public:
    friend class ASTxn;
    friend class I32Store;
    friend class I64Store;
    friend class F32Store;
    friend class F64Store;
    friend class ByteStore;

    ASEnv(const ASEnv&) =delete;

    ASEnv (ASEnv &&other) {
        _handle = other._handle;
        other._handle = nullptr;
    }

    ASEnv (const char *dbpath) {
        _handle = asenv_new (dbpath);
        // TODO better exception
        if (! _handle)
            throw std::runtime_error {"Open failed"};
    }
    ASEnv (const char *dbpath, size_t mapsize) {
        _handle = asenv_new_mapsize (dbpath, mapsize);
        // TODO better exception
        if (! _handle)
            throw std::runtime_error {"Open failed"};
    }
    ~ASEnv () {
        asenv_destroy (&_handle);        
    }
};


//  ----------------------------------------------------------------------
//  astxn_t wrapper

class ASTxn {
    astxn_t *_handle = nullptr;
    ASTxn (astxn_t *han) { _handle = han; }
public:
    friend class I32Store;
    friend class I64Store;
    friend class F32Store;
    friend class F64Store;
    friend class ByteStore;

    ASTxn(const ASTxn&) =delete;
    ~ASTxn () {
        astxn_destroy (&_handle);
    }
    ASTxn (ASTxn &&other) {
        _handle = other._handle;
        other._handle = nullptr;
    }

    static ASTxn makeRdrw (ASEnv &env) {
        astxn_t *han = astxn_new_rdrw (env._handle);
        // TODO better exception
        if (! han)
            throw std::runtime_error {"Txn open failed"};
        return ASTxn {han};
    }
    static ASTxn makeRdonly (ASEnv &env) {
        astxn_t *han = astxn_new_rdonly (env._handle);
        // TODO better exception
        if (! han)
            throw std::runtime_error {"Txn open failed"};
        return ASTxn {han};
    }
};


//  ----------------------------------------------------------------------
//  "int32_t" span

class I32Span {
    i32span _sp {nullptr, 0};
public:
    const int32_t * begin () const { return _sp.data; }
    const int32_t * end   () const { return _sp.data + _sp.size; }
    size_t          size  () const { return _sp.size; }

    int32_t operator[] (size_t n) { assert (_sp.data); return _sp.data [n]; }
    int32_t         at (size_t n) {
        if (n >= size()) throw std::length_error {"Outside span"};
        return operator[] (n);  }

    I32Span (i32span sp) { _sp = sp; }
};


//  ----------------------------------------------------------------------
//  "int32_t" array store

class I32Store {
    i32as_t *_handle = nullptr;
public:

    I32Store(const I32Store&) =delete;
    I32Store(I32Store &&other) {
        _handle = other._handle;
        other._handle = nullptr;
    }

    I32Store (ASEnv &env, const char *name) {
        _handle = i32as_new (env._handle, name);
        // TODO better exception
        if (! _handle)
            throw std::runtime_error {"Open failed"};
    }
    ~I32Store () {
        i32as_destroy (&_handle);
    }

    I32Span get (ASTxn &txn, Key key) {
        i32span sp = i32as_get (_handle, txn._handle, key);
        // TODO better exception
        if (sp.data == nullptr)
            throw std::runtime_error {"GET failed"};
        return I32Span {sp};
    }

    void put (ASTxn &txn, Key key, const int32_t *data, size_t size) {
        int rc = i32as_put (_handle, txn._handle, key, data, size);
        // TODO better exception
        if (rc)
            throw std::runtime_error {"PUT failed"};
    }

    bool exists (ASTxn &txn, Key key) {
        return i32as_exists (_handle, txn._handle, key);
    }
};


//  ----------------------------------------------------------------------
//  "int64_t" span

class I64Span {
    i64span _sp {nullptr, 0};
public:
    const int64_t * begin () const { return _sp.data; }
    const int64_t * end   () const { return _sp.data + _sp.size; }
    size_t          size  () const { return _sp.size; }

    int64_t operator[] (size_t n) { assert (_sp.data); return _sp.data [n]; }
    int64_t         at (size_t n) {
        if (n >= size()) throw std::length_error {"Outside span"};
        return operator[] (n);  }

    I64Span (i64span sp) { _sp = sp; }
};


//  ----------------------------------------------------------------------
//  "int64_t" array store

class I64Store {
    i64as_t *_handle = nullptr;
public:

    I64Store(const I64Store&) =delete;
    I64Store(I64Store &&other) {
        _handle = other._handle;
        other._handle = nullptr;
    }

    I64Store (ASEnv &env, const char *name) {
        _handle = i64as_new (env._handle, name);
        // TODO better exception
        if (! _handle)
            throw std::runtime_error {"Open failed"};
    }
    ~I64Store () {
        i64as_destroy (&_handle);
    }

    I64Span get (ASTxn &txn, Key key) {
        i64span sp = i64as_get (_handle, txn._handle, key);
        // TODO better exception
        if (sp.data == nullptr)
            throw std::runtime_error {"GET failed"};
        return I64Span {sp};
    }

    void put (ASTxn &txn, Key key, const int64_t *data, size_t size) {
        int rc = i64as_put (_handle, txn._handle, key, data, size);
        // TODO better exception
        if (rc)
            throw std::runtime_error {"PUT failed"};
    }

    bool exists (ASTxn &txn, Key key) {
        return i64as_exists (_handle, txn._handle, key);
    }
};


//  ----------------------------------------------------------------------
//  "float" span

class F32Span {
    f32span _sp {nullptr, 0};
public:
    const float * begin () const { return _sp.data; }
    const float * end   () const { return _sp.data + _sp.size; }
    size_t          size  () const { return _sp.size; }

    float operator[] (size_t n) { assert (_sp.data); return _sp.data [n]; }
    float         at (size_t n) {
        if (n >= size()) throw std::length_error {"Outside span"};
        return operator[] (n);  }

    F32Span (f32span sp) { _sp = sp; }
};


//  ----------------------------------------------------------------------
//  "float" array store

class F32Store {
    f32as_t *_handle = nullptr;
public:

    F32Store(const F32Store&) =delete;
    F32Store(F32Store &&other) {
        _handle = other._handle;
        other._handle = nullptr;
    }

    F32Store (ASEnv &env, const char *name) {
        _handle = f32as_new (env._handle, name);
        // TODO better exception
        if (! _handle)
            throw std::runtime_error {"Open failed"};
    }
    ~F32Store () {
        f32as_destroy (&_handle);
    }

    F32Span get (ASTxn &txn, Key key) {
        f32span sp = f32as_get (_handle, txn._handle, key);
        // TODO better exception
        if (sp.data == nullptr)
            throw std::runtime_error {"GET failed"};
        return F32Span {sp};
    }

    void put (ASTxn &txn, Key key, const float *data, size_t size) {
        int rc = f32as_put (_handle, txn._handle, key, data, size);
        // TODO better exception
        if (rc)
            throw std::runtime_error {"PUT failed"};
    }

    bool exists (ASTxn &txn, Key key) {
        return f32as_exists (_handle, txn._handle, key);
    }
};


//  ----------------------------------------------------------------------
//  "double" span

class F64Span {
    f64span _sp {nullptr, 0};
public:
    const double * begin () const { return _sp.data; }
    const double * end   () const { return _sp.data + _sp.size; }
    size_t          size  () const { return _sp.size; }

    double operator[] (size_t n) { assert (_sp.data); return _sp.data [n]; }
    double         at (size_t n) {
        if (n >= size()) throw std::length_error {"Outside span"};
        return operator[] (n);  }

    F64Span (f64span sp) { _sp = sp; }
};


//  ----------------------------------------------------------------------
//  "double" array store

class F64Store {
    f64as_t *_handle = nullptr;
public:

    F64Store(const F64Store&) =delete;
    F64Store(F64Store &&other) {
        _handle = other._handle;
        other._handle = nullptr;
    }

    F64Store (ASEnv &env, const char *name) {
        _handle = f64as_new (env._handle, name);
        // TODO better exception
        if (! _handle)
            throw std::runtime_error {"Open failed"};
    }
    ~F64Store () {
        f64as_destroy (&_handle);
    }

    F64Span get (ASTxn &txn, Key key) {
        f64span sp = f64as_get (_handle, txn._handle, key);
        // TODO better exception
        if (sp.data == nullptr)
            throw std::runtime_error {"GET failed"};
        return F64Span {sp};
    }

    void put (ASTxn &txn, Key key, const double *data, size_t size) {
        int rc = f64as_put (_handle, txn._handle, key, data, size);
        // TODO better exception
        if (rc)
            throw std::runtime_error {"PUT failed"};
    }

    bool exists (ASTxn &txn, Key key) {
        return f64as_exists (_handle, txn._handle, key);
    }
};


//  ----------------------------------------------------------------------
//  "unsigned char" span

class ByteSpan {
    bytespan _sp {nullptr, 0};
public:
    const unsigned char * begin () const { return _sp.data; }
    const unsigned char * end   () const { return _sp.data + _sp.size; }
    size_t          size  () const { return _sp.size; }

    unsigned char operator[] (size_t n) { assert (_sp.data); return _sp.data [n]; }
    unsigned char         at (size_t n) {
        if (n >= size()) throw std::length_error {"Outside span"};
        return operator[] (n);  }

    ByteSpan (bytespan sp) { _sp = sp; }
};


//  ----------------------------------------------------------------------
//  "unsigned char" array store

class ByteStore {
    byteas_t *_handle = nullptr;
public:

    ByteStore(const ByteStore&) =delete;
    ByteStore(ByteStore &&other) {
        _handle = other._handle;
        other._handle = nullptr;
    }

    ByteStore (ASEnv &env, const char *name) {
        _handle = byteas_new (env._handle, name);
        // TODO better exception
        if (! _handle)
            throw std::runtime_error {"Open failed"};
    }
    ~ByteStore () {
        byteas_destroy (&_handle);
    }

    ByteSpan get (ASTxn &txn, Key key) {
        bytespan sp = byteas_get (_handle, txn._handle, key);
        // TODO better exception
        if (sp.data == nullptr)
            throw std::runtime_error {"GET failed"};
        return ByteSpan {sp};
    }

    void put (ASTxn &txn, Key key, const unsigned char *data, size_t size) {
        int rc = byteas_put (_handle, txn._handle, key, data, size);
        // TODO better exception
        if (rc)
            throw std::runtime_error {"PUT failed"};
    }

    bool exists (ASTxn &txn, Key key) {
        return byteas_exists (_handle, txn._handle, key);
    }
};


}  // namespace arraystore
